import { AdapterBlueprint } from '@reown/appkit/adapters';
import { ConstantsUtil as CommonConstantsUtil } from '@reown/appkit-common';
import { AlertController, CoreHelperUtil, EventsController } from '@reown/appkit-core';
import { ConstantsUtil, ErrorUtil } from '@reown/appkit-utils';
import { Connection, PublicKey } from '@solana/web3.js';
import { SolConstantsUtil } from '@reown/appkit-utils/solana';
import { SolStoreUtil } from './utils/SolanaStoreUtil.js';
import { watchStandard } from './utils/watchStandard.js';
import { AuthProvider } from './providers/AuthProvider.js';
import { CoinbaseWalletProvider } from './providers/CoinbaseWalletProvider.js';
import { WcHelpersUtil } from '@reown/appkit';
import { W3mFrameProviderSingleton } from '@reown/appkit/auth-provider';
import { withSolanaNamespace } from './utils/withSolanaNamespace.js';
import UniversalProvider from '@walletconnect/universal-provider';
import { createSendTransaction } from './utils/createSendTransaction.js';
import { handleMobileWalletRedirection } from './utils/handleMobileWalletRedirection.js';
import { WalletConnectProvider } from './providers/WalletConnectProvider.js';
import bs58 from 'bs58';
export class SolanaAdapter extends AdapterBlueprint {
    constructor(options = {}) {
        super({});
        this.adapterType = 'solana';
        this.providerHandlers = null;
        this.namespace = CommonConstantsUtil.CHAIN.SOLANA;
        this.connectionSettings = options.connectionSettings || 'confirmed';
        this.wallets = options.wallets;
        EventsController.subscribe(state => {
            if (state.data.event === 'SELECT_WALLET') {
                const isMobile = CoreHelperUtil.isMobile();
                const isClient = CoreHelperUtil.isClient();
                if (isMobile && isClient) {
                    handleMobileWalletRedirection(state.data.properties);
                }
            }
        });
    }
    syncConnectors(options, appKit) {
        if (!options.projectId) {
            AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, 'error');
        }
        const emailEnabled = options.features?.email !== false;
        const socialsEnabled = options.features?.socials !== false &&
            Array.isArray(options.features?.socials) &&
            options.features.socials.length > 0;
        if (emailEnabled || socialsEnabled) {
            this.w3mFrameProvider = W3mFrameProviderSingleton.getInstance({
                projectId: options.projectId,
                chainId: withSolanaNamespace(appKit?.getCaipNetwork(this.namespace)?.id),
                onTimeout: () => {
                    AlertController.open(ErrorUtil.ALERT_ERRORS.INVALID_APP_CONFIGURATION, 'error');
                }
            });
            this.authProvider = new AuthProvider({
                getProvider: () => this.w3mFrameProvider,
                getActiveChain: () => appKit.getCaipNetwork(this.namespace),
                getActiveNamespace: () => appKit.getActiveChainNamespace(),
                getSession: () => this.authSession,
                setSession: session => {
                    this.authSession = session;
                },
                chains: this.caipNetworks
            });
            this.addConnector({
                id: ConstantsUtil.AUTH_CONNECTOR_ID,
                type: 'AUTH',
                provider: this.authProvider,
                name: 'Auth',
                chain: this.namespace,
                chains: []
            });
        }
        if ('coinbaseSolana' in window) {
            this.addConnector({
                id: 'coinbaseWallet',
                type: 'EXTERNAL',
                provider: new CoinbaseWalletProvider({
                    provider: window.coinbaseSolana,
                    chains: this.caipNetworks,
                    getActiveChain: () => appKit.getCaipNetwork(this.namespace)
                }),
                name: 'Coinbase Wallet',
                chain: this.namespace,
                chains: []
            });
        }
        watchStandard(this.caipNetworks, () => appKit.getCaipNetwork(this.namespace), (...providers) => {
            providers.forEach(provider => {
                this.addConnector({
                    id: provider.name,
                    type: 'ANNOUNCED',
                    provider: provider,
                    imageUrl: provider.icon,
                    name: provider.name,
                    chain: CommonConstantsUtil.CHAIN.SOLANA,
                    chains: []
                });
            });
        });
    }
    async getEnsAddress(params) {
        return { address: params.name };
    }
    async writeContract() {
        return Promise.resolve({
            hash: ''
        });
    }
    async getCapabilities() {
        return Promise.resolve({});
    }
    async grantPermissions() {
        return Promise.resolve({});
    }
    async revokePermissions() {
        return Promise.resolve('0x');
    }
    async signMessage(params) {
        const walletStandardProvider = params.provider;
        if (!walletStandardProvider) {
            throw new Error('connectionControllerClient:signMessage - provider is undefined');
        }
        const signature = await walletStandardProvider.signMessage(new TextEncoder().encode(params.message));
        return {
            signature: bs58.encode(signature)
        };
    }
    async estimateGas(params) {
        const connection = SolStoreUtil.state.connection;
        if (!connection || !params.provider) {
            throw new Error('Connection is not set');
        }
        const transaction = await createSendTransaction({
            provider: params.provider,
            connection,
            to: '11111111111111111111111111111111',
            value: 1
        });
        const fee = await transaction.getEstimatedFee(connection);
        return {
            gas: BigInt(fee || 0)
        };
    }
    async sendTransaction(params) {
        const connection = SolStoreUtil.state.connection;
        if (!connection || !params.address || !params.provider) {
            throw new Error('Connection is not set');
        }
        const walletStandardProvider = params.provider;
        const transaction = await createSendTransaction({
            provider: walletStandardProvider,
            connection,
            to: params.to,
            value: params.value
        });
        const result = await walletStandardProvider.sendTransaction(transaction, connection);
        await new Promise(resolve => {
            const interval = setInterval(async () => {
                const status = await connection.getSignatureStatus(result);
                if (status?.value) {
                    clearInterval(interval);
                    resolve();
                }
            }, 1000);
        });
        return {
            hash: result
        };
    }
    parseUnits() {
        return 0n;
    }
    formatUnits() {
        return '';
    }
    async connect(params) {
        const { id, type, rpcUrl } = params;
        const selectedProvider = this.connectors.find(c => c.id === id)?.provider;
        if (!selectedProvider) {
            throw new Error('Provider not found');
        }
        let address;
        if (type === 'AUTH') {
            const data = await this.authProvider?.connect();
            if (!data) {
                throw new Error('No address found');
            }
            address = data;
        }
        else {
            address = await selectedProvider.connect();
        }
        this.listenProviderEvents(selectedProvider);
        SolStoreUtil.setConnection(new Connection(rpcUrl, 'confirmed'));
        return {
            address,
            chainId: params.chainId,
            provider: selectedProvider,
            type: type,
            id
        };
    }
    async getBalance(params) {
        const connection = new Connection(params.caipNetwork?.rpcUrls?.default?.http?.[0], this.connectionSettings);
        const balance = await connection.getBalance(new PublicKey(params.address));
        const formattedBalance = (balance / SolConstantsUtil.LAMPORTS_PER_SOL).toString();
        if (!params.caipNetwork) {
            throw new Error('caipNetwork is required');
        }
        return {
            balance: formattedBalance,
            symbol: params.caipNetwork?.nativeCurrency.symbol
        };
    }
    async switchNetwork(params) {
        const { caipNetwork, provider, providerType } = params;
        if (providerType === 'ID_AUTH') {
            await provider.switchNetwork(caipNetwork.id);
            const user = await provider.getUser({
                chainId: caipNetwork.id
            });
            this.authSession = user;
            this.emit('switchNetwork', { chainId: caipNetwork.id, address: user.address });
        }
        if (caipNetwork?.rpcUrls?.default?.http?.[0]) {
            SolStoreUtil.setConnection(new Connection(caipNetwork.rpcUrls.default.http[0], this.connectionSettings));
        }
    }
    listenProviderEvents(provider) {
        const disconnectHandler = () => {
            this.removeProviderListeners(provider);
            this.emit('disconnect');
        };
        const accountsChangedHandler = (publicKey) => {
            const address = publicKey.toBase58();
            if (address) {
                this.emit('accountChanged', { address });
            }
        };
        provider.on('disconnect', disconnectHandler);
        provider.on('accountsChanged', accountsChangedHandler);
        provider.on('connect', accountsChangedHandler);
        this.providerHandlers = {
            disconnect: disconnectHandler,
            accountsChanged: accountsChangedHandler
        };
    }
    removeProviderListeners(provider) {
        if (this.providerHandlers) {
            provider.removeListener('disconnect', this.providerHandlers.disconnect);
            provider.removeListener('accountsChanged', this.providerHandlers.accountsChanged);
            provider.removeListener('connect', this.providerHandlers.accountsChanged);
            this.providerHandlers = null;
        }
    }
    async connectWalletConnect(onUri) {
        const connector = this.connectors.find(c => c.type === 'WALLET_CONNECT');
        const provider = connector?.provider;
        if (!this.caipNetworks || !provider) {
            throw new Error('UniversalAdapter:connectWalletConnect - caipNetworks or provider is undefined');
        }
        provider.on('display_uri', (uri) => {
            onUri(uri);
        });
        const namespaces = WcHelpersUtil.createNamespaces(this.caipNetworks);
        await provider.connect({ optionalNamespaces: namespaces });
    }
    async disconnect(params) {
        if (!params.provider || !params.providerType) {
            throw new Error('Provider or providerType not provided');
        }
        await params.provider.disconnect();
    }
    async getProfile() {
        return Promise.resolve({
            profileName: undefined,
            profileImage: undefined
        });
    }
    async syncConnection(params) {
        const { id, rpcUrl } = params;
        const connector = this.connectors.find(c => c.id === id);
        const selectedProvider = connector?.provider;
        if (!selectedProvider) {
            throw new Error('Provider not found');
        }
        if (connector?.type === 'AUTH') {
            const authProvider = selectedProvider;
            const user = await authProvider.getUser({
                chainId: Number(this.caipNetworks?.[0]?.id)
            });
            if (!user?.address) {
                throw new Error('No address found');
            }
            return {
                address: user.address,
                chainId: typeof user.chainId === 'string' ? Number(user.chainId.split(':')[1]) : 1,
                provider: selectedProvider,
                type: connector.type,
                id
            };
        }
        const address = await selectedProvider.connect();
        const chainId = this.caipNetworks?.[0]?.id || 1;
        this.listenProviderEvents(selectedProvider);
        SolStoreUtil.setConnection(new Connection(rpcUrl, 'confirmed'));
        return {
            address,
            chainId,
            provider: selectedProvider,
            type: connector?.type,
            id
        };
    }
    getWalletConnectProvider(params) {
        const walletConnectProvider = new WalletConnectProvider({
            provider: params.provider,
            chains: params.caipNetworks,
            getActiveChain: () => params.activeCaipNetwork
        });
        return walletConnectProvider;
    }
}
//# sourceMappingURL=client.js.map